namespace pptb::analysis
{
	template <typename rtype>
	struct plane_t
	{
		using value_type = rtype;
		
		// Member variables
		std::array<value_type, 3> nvec; // Plane normal
		std::array<value_type, 3> tvec; // Plane tangential vector 1
		std::array<value_type, 3> mvec; // plane tangential vector 2
	};
	
	template <typename rtype, const std::size_t num_slices>
	struct plane_slice_t
	{
		using value_type  = rtype;
		using surf_geom_t = geom::surf_geom_t<value_type>;
		
		// Member variables
		std::array<surf_geom_t, num_slices> slice_data; // Cross-section geometry and data
		std::array<std::size_t, num_slices> slice_plane; // Slice plane
		std::array<value_type, num_slices> slice_pos; // Slice position in plane normal direction
		std::array<plane_t<value_type>, num_slices> planes; // Slice plane basis
		
		// Some functions
		constexpr static int nslice(){return num_slices;}

		// Constructor --> slice select based on Cartesian planes
	    plane_slice_t(const std::array<std::string, num_slices>& slice_plane_in, const auto& slice_pos_in) : slice_pos{slice_pos_in}
		{
			print("Initializing slice operator...");

			for (int n = 0; n<nslice(); n++)
			{
				if (slice_plane_in[n] == "XY" || slice_plane_in[n] == "YX")
				{
					slice_plane[n] = 1;
					planes[n].nvec = {0.0, 0.0, 1.0};
					planes[n].tvec = {1.0, 0.0, 0.0};
					planes[n].mvec = utils::cross_prod(planes[n].nvec, planes[n].tvec);
				}
				else if (slice_plane_in[n] == "XZ" || slice_plane_in[n] == "ZX")
				{
					slice_plane[n] = 2;
					planes[n].nvec = {0.0, 1.0, 0.0};
					planes[n].tvec = {1.0, 0.0, 0.0};
					planes[n].mvec = utils::cross_prod(planes[n].nvec, planes[n].tvec);
				}
				else if (slice_plane_in[n] == "YZ" || slice_plane_in[n] == "ZY")
				{
					slice_plane[n] = 3;
					planes[n].nvec = {1.0, 0.0, 0.0};
					planes[n].tvec = {0.0, 1.0, 0.0};
					planes[n].mvec = utils::cross_prod(planes[n].nvec, planes[n].tvec);
				}
				else
				{
					slice_plane[n] = 1e9;
					print("Invalid slice plane selected!");
				}
				print("   Slice = ",n," plane,ID = ",slice_plane[n],slice_plane_in[n]);
				print("      nvec = ",planes[n].nvec[0], planes[n].nvec[1], planes[n].nvec[2]);
				print("      tvec = ",planes[n].tvec[0], planes[n].tvec[1], planes[n].tvec[2]);
				print("      mvec = ",planes[n].mvec[0], planes[n].mvec[1], planes[n].mvec[2]);
			}
		}



		// Function to extract data from specified geometry
		template <typename geom_t>
		inline void extract_data(const geom_t& surface)
		{
			print("Running slice plane extractor...");
			
			// First, find average dx on surface geometry
			value_type dx_avg = 0.0;
			for (int n = 0; n<surface.connect.size(); n++)
			{
				// Node list for this element
				const auto& connect = surface.connect[n];

				// Node coordinates
				const auto& node0 = surface.nodes[connect[0]];
				const auto& node1 = surface.nodes[connect[1]];
				const auto& node2 = surface.nodes[connect[2]];

				// Grid spacings
				const auto dx0   = utils::array_norm(node0, node1);
				const auto dx1   = utils::array_norm(node0, node2);
				const auto dx2   = utils::array_norm(node1, node2);

				// Average spacing
				dx_avg += (dx0 + dx1 + dx2) / value_type(3.0 * surface.connect.size());
				print(connect[0],node0[0],node0[1],node0[2]);
				print(connect[1],node1[0],node1[1],node1[2]);
				print(connect[2],node2[0],node2[1],node2[2]);
				print(n,dx0,dx1,dx2,value_type(3.0 * surface.connect.size()),dx_avg);
				std::cin.get();
			}

			print("Avg. surface spacing = ",dx_avg);
			
			// Loop slice planes
			for (int islice = 0; islice<nslice(); islice++)
			{
				print("   Extracting data on slice plane ",islice);

				// Grab slice data structure
				auto& geom = slice_data[islice];

				
			}
		}
	};
}
